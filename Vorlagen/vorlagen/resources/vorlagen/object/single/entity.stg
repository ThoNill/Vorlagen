group DIALOG ;

overwrite(model) ::= "true"
create(model) ::= "true"

mypfad() ::= "entities"

dateiName(model) ::= "$mypfad()$/$model.class.simpleName$.java"

dateiInhalt(model) ::= <<
$DATA(model,model.class.simpleName,mypfad())$

>>

DATA(x,classname,pfad) ::= <<
package $pfad$;


import java.io.Serializable;
import java.util.Date;
import java.util.HashSet;
import java.util.Set;

import javax.persistence.Basic;
import javax.persistence.CascadeType;
import javax.persistence.CollectionTable;
import javax.persistence.Column;
import javax.persistence.ElementCollection;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.SequenceGenerator;
import javax.persistence.Table;

import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.ToString;

@Data
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
@ToString(onlyExplicitlyIncluded = true)
@Entity
@Table(name = "$classname; format="upper"$")
@SequenceGenerator(name = "$classname; format="upper"$_SEQ", sequenceName = "$classname; format="upper"$_SEQ")
public class $classname$ implements I$classname; format="cap"$ {

    @EqualsAndHashCode.Include
    @ToString.Include
    @Basic
    @Column(name = "$classname; format="upper"$ID")
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "$classname; format="upper"$_SEQ")
    private java.lang.Long $classname$Id;

    $x.values:elements()$
}

>>

elements(v) ::= <<
	$(v.kind)(v)$
>>
	
value(v) ::= <<	
	@Basic
    @Column(name = "$v.name; format="upper"$")
    private $v.clazz.simpleName$ $v.name$;

>>

fromone2many(v) ::= << 

    @OneToMany(cascade = CascadeType.ALL, 
               mappedBy = "$v.name$_$v.source.simpleName$", 
               orphanRemoval = true
               )
    private Set<$v.target.simpleName$> $v.name$_$v.target.simpleName$ = new HashSet<>();


    @Override
    public void add$v.name; format="cap"$($v.target.simpleName$ x) {
        this.$v.name$_$v.target.simpleName$.add(x);
        x.set$v.name; format="cap"$_$v.source.simpleName$(this);
    }

    @Override
    public void remove$v.name; format="cap"$($v.target.simpleName$ x) {
        this.$v.name$_$v.target.simpleName$.remove(x);
        x.set$v.name; format="cap"$_$v.source.simpleName$(null);
    }


>>

toone2many(v) ::= << 
/*
    @ElementCollection
    @CollectionTable(name = "$v.source.simpleName$_$v.target.simpleName$", joinColumns = @JoinColumn(name = "$v.target.simpleName; format="upper"$ID"))
    private Set<$v.target.simpleName$> $v.name$ = new HashSet<>();
*/
 
  	@ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "$v.source.simpleName$_Id")
	private <$v.source.simpleName$> $v.name$_$v.source.simpleName$;
    
    @Override
    public void setI$v.name$_$v.source.simpleName; format="cap"$(I$v.source.simpleName$ $v.name$) {
    set$v.name; format="cap"$_$v.source.simpleName$(($v.source.simpleName$) $v.name$);
    }



>>



frommany2many(v) ::= << 
    @ManyToMany(cascade = { CascadeType.ALL }, 
                fetch = FetchType.LAZY)
    @JoinTable(name = "$v.source.simpleName$_$v.target.simpleName$", 
    joinColumns = { @JoinColumn(name = "$v.source.simpleName$Id") }, 
    inverseJoinColumns = { @JoinColumn(name = "$v.target.simpleName$Id") })
    private Set<$v.target.simpleName$> $v.name$_$v.target.simpleName$ = new HashSet<>();

>>

tomany2many(v) ::= << 
    @ManyToMany(mappedBy = "$v.name$_$v.target.simpleName$")
    private Set<$v.source.simpleName$> $v.name$_$v.source.simpleName$ = new HashSet<>();
>>


fromone2one(v) ::= << 
    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = "$v.target.simpleName$_Id", 
                referencedColumnName = "$v.source.simpleName$_Id")
    private $v.target.simpleName$ $v.name$_$v.target.simpleName$;

>>

toone2one(v) ::= << 
    @OneToOne(mappedBy = "$v.name$_$v.target.simpleName$")
    private $v.source.simpleName$ $v.name$_$v.source.simpleName$;

>>

entity() ::= <<
import java.util.Date;
import java.util.HashSet;
import java.util.Set;

import javax.persistence.Basic;
import javax.persistence.CascadeType;
import javax.persistence.CollectionTable;
import javax.persistence.Column;
import javax.persistence.ElementCollection;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.SequenceGenerator;
import javax.persistence.Table;

import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.ToString;

import org.nill.abrechnung.interfaces.IAbrechnung;
import org.nill.abrechnung.interfaces.IBuchung;
import org.nill.abrechnung.values.KontoBewegung;
import org.nill.allgemein.values.TypeReference;

@Data
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
@ToString(onlyExplicitlyIncluded = true)
@Entity
@Table(name = "BUCHUNG")
@SequenceGenerator(name = "BUCHUNG_SEQ", sequenceName = "BUCHUNG_SEQ")
public class Buchung implements IBuchung {

    @EqualsAndHashCode.Include
    @ToString.Include
    @Basic
    @Column(name = "BUCHUNGID")
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "BUCHUNG_SEQ")
    private java.lang.Long buchungId;

    @Basic
    @Column(name = "BUCHUNGSDATUM")
    private Date buchungsDatum;

    @ToString.Include
    @Basic
    @Column(name = "TEXT")
    private String text;

    @EqualsAndHashCode.Include
    @ToString.Include
    @Basic
    @Column(name = "ART")
    private int art;

    @ElementCollection
    @CollectionTable(name = "Buchung_KontoBewegung", joinColumns = @JoinColumn(name = "BUCHUNGID"))
    private Set<KontoBewegung> bewegungen = new HashSet<>();

    @ManyToOne(cascade = CascadeType.PERSIST)
    @JoinColumn(name = "AbrechnungId")
    private Abrechnung abrechnung;

    @ElementCollection
    @CollectionTable(name = "Buchung_TypeReference", joinColumns = @JoinColumn(name = "BUCHUNGID"))
    private Set<TypeReference> bezüge = new HashSet<>();

    @Override
    public void addBewegungen(KontoBewegung bewegungen) {
        this.bewegungen.add(bewegungen);
    }

    @Override
    public void removeBewegungen(KontoBewegung bewegungen) {
        this.bewegungen.remove(bewegungen);
    }

    @Override
    public void addBezug(TypeReference bezug) {
        this.bezüge.add(bezug);
    }

    @Override
    public void removeBezug(TypeReference bezug) {
        this.bezüge.remove(bezug);
    }

    @Override
    public void setIAbrechnung(IAbrechnung abrechnung2) {
        setAbrechnung((Abrechnung) abrechnung2);
    }
>>

interface() ::= <<

package org.nill.abrechnung.interfaces;

import java.util.Date;
import java.util.Set;

import org.nill.abrechnung.values.KontoBewegung;
import org.nill.allgemein.values.TypeReference;

public interface IBuchung {

    public void addBewegungen(KontoBewegung bewegungen);

    public void removeBewegungen(KontoBewegung bewegungen);

    public void addBezug(TypeReference bezug);

    public void removeBezug(TypeReference bezug);

    public void setIAbrechnung(IAbrechnung abrechnung2);

    public java.lang.Long getBuchungId();

    public void setBuchungId(java.lang.Long buchungId);

    public Date getBuchungsDatum();

    public void setBuchungsDatum(Date buchungsDatum);

    public String getText();

    public void setText(String text);

    public int getArt();

    public void setArt(int art);

    public Set<KontoBewegung> getBewegungen();

    public void setBewegungen(Set<KontoBewegung> bewegungen);

    public Set<TypeReference> getBezüge();

    public void setBezüge(Set<TypeReference> bezüge);

    public IAbrechnung getAbrechnung();

}
>>

valueobject() ::= <<

package org.nill.abrechnung.values;

import javax.persistence.Basic;
import javax.persistence.Column;
import javax.persistence.Convert;
import javax.persistence.Embeddable;

import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.ToString;

@Data
@EqualsAndHashCode
@ToString
@Embeddable
public class KontoBewegung {

    @Basic
    @Column(name = "ART")
    private int art;

    @Basic
    @Column(name = "KONTONR")
    private int kontoNr;

    @Basic
    @Column(name = "BETRAG")
    @Convert(converter = org.nill.basiskomponenten.betrag.GeldKonverter.class)
    private javax.money.MonetaryAmount betrag;
}
>>